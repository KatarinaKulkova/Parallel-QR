import numpy as np
from scipy.linalg import solve_triangular
import multiprocessing as mp
import matplotlib.pyplot as plt

num = mp.cpu_count()


def parallel_qr(matrix):
    ms = np.array_split(matrix, num)
    qs1, rs = zip(*map(np.linalg.qr, ms))
    r1 = np.concatenate(rs)
    q, r2 = np.linalg.qr(r1)
    qs2 = np.array_split(q, num)
    qs = list(map(np.matmul, qs1, qs2))
    return np.concatenate(qs), r2


def least_squares(matrix, vector):
    q, r = parallel_qr(matrix)
    rhs = np.dot(np.transpose(q), vector)
    return solve_triangular(r, rhs)


def generate_row(degree, elem):
    return list(map(lambda i: elem ** i, range(0, degree + 1)))


def generate_points(coefs, min_x, max_x):
    xs = np.linspace(min_x, max_x, num=100)
    ys = list(map(lambda x: np.polyval(np.flip(np.array(coefs), axis=0), x), xs))
    return xs, ys


def cart_to_pol(x, y):
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)
    return theta, r


def plot_data(polar, x, y, coefs):
    if not polar:
        plt.plot(x, y, 'ro')
        plt.plot(*generate_points(coefs, min(x), max(x)))
        plt.show()
    if polar:
        ax = plt.subplot(111, polar=True)
        ax.plot(x, y, 'ro')
        ax.plot(*generate_points(coefs, min(x), max(x)))
        plt.show()


def process_data(path, polar):
    x, y = np.loadtxt(path, unpack=True)
    arg1 = x
    arg2 = y
    if polar:
        ts, arg2 = zip(*list(map(cart_to_pol, x, y)))
        arg1 = np.unwrap(ts)
    matrix = list(map(lambda e: generate_row(2, e), arg1))
    coefs = least_squares(matrix, arg2)
    plot_data(polar, arg1, arg2, coefs)


def process_data1():
    x, y = np.loadtxt("Data/Data1", unpack=True)
    matrix = list(map(lambda e: generate_row(2, e), x))
    coefs = least_squares(matrix, y)
    plt.plot(x, y, 'ro')
    plt.plot(*generate_points(coefs, min(x), max(x)))
    plt.show()


def process_data2():
    x, y = np.loadtxt("Data/Data2", unpack=True)
    thetas, rs = zip(*list(map(cart_to_pol, x, y)))
    t = np.unwrap(thetas)
    matrix = list(map(lambda e: generate_row(1, e), t))
    coefs = least_squares(matrix, rs)
    ax = plt.subplot(111, polar=True)
    ax.plot(t, rs, 'ro')
    ax.plot(*generate_points(coefs, min(t), max(t)))
    plt.show()


process_data("Data/Data2", True)
