import numpy as np
from scipy.linalg import solve_triangular
import multiprocessing as mp
import matplotlib.pyplot as plt


output = mp.Queue()
num = mp.cpu_count()


def parallel_qr(matrix):
    ms = np.array_split(matrix, num)
    qs1, rs = zip(*map(np.linalg.qr, ms))
    r1 = np.concatenate(rs)
    q, r2 = np.linalg.qr(r1)
    qs2 = np.array_split(q, num)
    qs = list(map(np.matmul, qs1, qs2))
    return np.concatenate(qs), r2


def least_squares(matrix, vector):
    q, r = parallel_qr(matrix)
    rhs = np.dot(np.transpose(q), vector)
    return solve_triangular(r, rhs)


def generate_row(degree, elem):
    return list(map(lambda i: elem ** i, range(0, degree + 1)))


def generate_points(coefs, min_x, max_x):
    xs = np.linspace(min_x, max_x, num=100)
    ys = list(map(lambda x: np.polyval(np.flip(np.array(coefs), axis=0), x), xs))
    return xs, ys


def process_data1():
    x, y = np.loadtxt("Data/Data1", unpack=True)
    matrix = list(map(lambda e: generate_row(2, e), x))
    coefs = least_squares(matrix, y)
    plt.plot(x, y, 'ro')
    plt.plot(*generate_points(coefs, min(x), max(x)))
    plt.show()


process_data1()
